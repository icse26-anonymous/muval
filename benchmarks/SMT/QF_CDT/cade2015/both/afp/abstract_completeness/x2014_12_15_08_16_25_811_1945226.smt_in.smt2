; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --random-seed=1 --lang=smt2 --tlimit 7
;(set-option :produce-unsat-cores true)
(set-logic ALL_SUPPORTED)
(declare-sort Nat$ 0)
(declare-sort Rule$ 0)
(declare-sort State$ 0)
(declare-sort Rule_set$ 0)
(declare-sort State_set$ 0)
(declare-sort State_fset$ 0)
(declare-sort Nat_bool_fun$ 0)
(declare-sort Rule_rule_fun$ 0)
(declare-sort Rule_state_fun$ 0)
(declare-sort State_rule_fun$ 0)
(declare-sort State_state_fun$ 0)
(declare-sort Rule_rule_prod_set$ 0)
(declare-sort State_fset_bool_fun$ 0)
(declare-sort State_rule_prod_set$ 0)
(declare-sort State_rule_prod_tree$ 0)
(declare-sort Rule_rule_rule_fun_fun$ 0)
(declare-sort Rule_rule_state_fun_fun$ 0)
(declare-sort Rule_state_rule_fun_fun$ 0)
(declare-sort State_rule_rule_fun_fun$ 0)
(declare-sort Rule_state_state_fun_fun$ 0)
(declare-sort State_rule_prod_rule_fun$ 0)
(declare-sort State_rule_state_fun_fun$ 0)
(declare-sort State_state_rule_fun_fun$ 0)
(declare-sort State_state_state_fun_fun$ 0)
(declare-sort State_state_fset_bool_fun_fun$ 0)
(declare-sort Rule_rule_prod_rule_rule_fun_fun$ 0)
(declare-sort Rule_rule_rule_prod_rule_fun_fun$ 0)
(declare-sort Rule_rule_rule_rule_prod_fun_fun$ 0)
(declare-sort Rule_state_rule_prod_rule_fun_fun$ 0)
(declare-sort State_rule_prod_rule_rule_fun_fun$ 0)
(declare-sort Rule_state_state_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_rule_prod_rule_rule_prod_rule_fun_fun$ 0)
(declare-sort Rule_rule_prod_rule_rule_rule_prod_fun_fun$ 0)
(declare-sort Rule_rule_rule_prod_rule_rule_prod_fun_fun$ 0)
(declare-sort Rule_rule_prod_rule_rule_prod_rule_rule_prod_fun_fun$ 0)
(declare-codatatypes () ((Rule_stream$ (sCons$ (shd$ Rule$) (stl$ Rule_stream$)))
  (State_stream$ (sCons$a (shd$a State$) (stl$a State_stream$)))))
(declare-datatypes () ((State_rule_prod$ (pair$ (fst$ State$) (snd$ Rule$)))))
(declare-codatatypes () ((State_rule_prod_stream$ (sCons$b (shd$b State_rule_prod$) (stl$b State_rule_prod_stream$)))))
(declare-datatypes () ((Rule_rule_prod$ (pair$a (fst$a Rule$) (snd$a Rule$)))
  (Rule_rule_prod_rule_rule_prod_prod$ (pair$b (fst$b Rule_rule_prod$) (snd$b Rule_rule_prod$)))))
(declare-codatatypes () ((Rule_rule_prod_rule_rule_prod_prod_stream$ (sCons$c (shd$c Rule_rule_prod_rule_rule_prod_prod$) (stl$c Rule_rule_prod_rule_rule_prod_prod_stream$)))))
(declare-datatypes () ((Rule_rule_prod_rule_prod$ (pair$c (fst$c Rule_rule_prod$) (snd$c Rule$)))))
(declare-codatatypes () ((Rule_rule_prod_rule_prod_stream$ (sCons$d (shd$d Rule_rule_prod_rule_prod$) (stl$d Rule_rule_prod_rule_prod_stream$)))))
(declare-datatypes () ((Rule_rule_rule_prod_prod$ (pair$d (fst$d Rule$) (snd$d Rule_rule_prod$)))))
(declare-codatatypes () ((Rule_rule_rule_prod_prod_stream$ (sCons$e (shd$e Rule_rule_rule_prod_prod$) (stl$e Rule_rule_rule_prod_prod_stream$)))
  (Rule_rule_prod_stream$ (sCons$f (shd$f Rule_rule_prod$) (stl$f Rule_rule_prod_stream$)))))
(declare-datatypes () ((State_state_prod$ (pair$e (fst$e State$) (snd$e State$)))))
(declare-codatatypes () ((State_state_prod_stream$ (sCons$g (shd$g State_state_prod$) (stl$g State_state_prod_stream$)))))
(declare-datatypes () ((Rule_state_prod$ (pair$f (fst$f Rule$) (snd$f State$)))))
(declare-codatatypes () ((Rule_state_prod_stream$ (sCons$h (shd$h Rule_state_prod$) (stl$h Rule_state_prod_stream$)))))
(declare-datatypes () ((State_state_rule_prod_prod$ (pair$g (fst$g State$) (snd$g State_rule_prod$)))))
(declare-codatatypes () ((State_state_rule_prod_prod_stream$ (sCons$i (shd$i State_state_rule_prod_prod$) (stl$i State_state_rule_prod_prod_stream$)))))
(declare-datatypes () ((Rule_state_rule_prod_prod$ (pair$h (fst$h Rule$) (snd$h State_rule_prod$)))))
(declare-codatatypes () ((Rule_state_rule_prod_prod_stream$ (sCons$j (shd$j Rule_state_rule_prod_prod$) (stl$j Rule_state_rule_prod_prod_stream$)))))
(declare-datatypes () ((Rule_rule_prod_state_prod$ (pair$i (fst$i Rule_rule_prod$) (snd$i State$)))))
(declare-codatatypes () ((Rule_rule_prod_state_prod_stream$ (sCons$k (shd$k Rule_rule_prod_state_prod$) (stl$k Rule_rule_prod_state_prod_stream$)))))
(declare-datatypes () ((State_rule_rule_prod_prod$ (pair$j (fst$j State$) (snd$j Rule_rule_prod$)))))
(declare-codatatypes () ((State_rule_rule_prod_prod_stream$ (sCons$l (shd$l State_rule_rule_prod_prod$) (stl$l State_rule_rule_prod_prod_stream$)))))
(declare-datatypes () ((State_rule_prod_rule_prod$ (pair$k (fst$k State_rule_prod$) (snd$k Rule$)))))
(declare-codatatypes () ((State_rule_prod_rule_prod_stream$ (sCons$m (shd$m State_rule_prod_rule_prod$) (stl$m State_rule_prod_rule_prod_stream$)))))
(declare-datatypes () ((State_rule_prod_state_prod$ (pair$l (fst$l State_rule_prod$) (snd$l State$)))))
(declare-codatatypes () ((State_rule_prod_state_prod_stream$ (sCons$n (shd$n State_rule_prod_state_prod$) (stl$n State_rule_prod_state_prod_stream$)))))
(declare-datatypes () ((State_rule_prod_state_rule_prod_prod$ (pair$m (fst$m State_rule_prod$) (snd$m State_rule_prod$)))))
(declare-codatatypes () ((State_rule_prod_state_rule_prod_prod_stream$ (sCons$o (shd$o State_rule_prod_state_rule_prod_prod$) (stl$o State_rule_prod_state_rule_prod_prod_stream$)))))
(declare-datatypes () ((Rule_state_state_prod_prod$ (pair$n (fst$n Rule$) (snd$n State_state_prod$)))))
(declare-codatatypes () ((Rule_state_state_prod_prod_stream$ (sCons$p (shd$p Rule_state_state_prod_prod$) (stl$p Rule_state_state_prod_prod_stream$)))))
(declare-fun n$ () Nat$)
(declare-fun r$ () Rule$)
(declare-fun s$ () State$)
(declare-fun rs$ () Rule_stream$)
(declare-fun s$a () State_set$)
(declare-fun uu$ (Rule_stream$ State$) Nat_bool_fun$)
(declare-fun eff$ () Rule_state_state_fset_bool_fun_fun_fun$)
(declare-fun fair$ (Rule_stream$ Rule_stream$) Bool)
(declare-fun root$ (State_rule_prod_tree$) State_rule_prod$)
(declare-fun snth$ (Rule_stream$ Nat$) Rule$)
(declare-fun sset$ (Rule_stream$) Rule_set$)
(declare-fun szip$ (Rule_stream$ Rule_stream$) Rule_rule_prod_stream$)
(declare-fun trim$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) Rule_stream$)
(declare-fun fair$a (State_stream$ State_stream$) Bool)
(declare-fun fair$b (State_rule_prod_stream$ State_rule_prod_stream$) Bool)
(declare-fun fair$c (Rule_rule_prod_rule_rule_prod_prod_stream$ Rule_rule_prod_rule_rule_prod_prod_stream$) Bool)
(declare-fun fair$d (Rule_rule_prod_rule_prod_stream$ Rule_rule_prod_rule_prod_stream$) Bool)
(declare-fun fair$e (Rule_rule_rule_prod_prod_stream$ Rule_rule_rule_prod_prod_stream$) Bool)
(declare-fun fair$f (Rule_rule_prod_stream$ Rule_rule_prod_stream$) Bool)
(declare-fun least$ (Nat_bool_fun$) Nat$)
(declare-fun rules$ () Rule_stream$)
(declare-fun sdrop$ (Nat$ Rule_stream$) Rule_stream$)
(declare-fun smap2$ (Rule_rule_rule_fun_fun$ Rule_stream$ Rule_stream$) Rule_stream$)
(declare-fun snth$a (State_stream$ Nat$) State$)
(declare-fun snth$b (State_rule_prod_stream$ Nat$) State_rule_prod$)
(declare-fun snth$c (Rule_rule_prod_stream$ Nat$) Rule_rule_prod$)
(declare-fun snth$d (State_state_prod_stream$ Nat$) State_state_prod$)
(declare-fun snth$e (Rule_state_prod_stream$ Nat$) Rule_state_prod$)
(declare-fun snth$f (State_state_rule_prod_prod_stream$ Nat$) State_state_rule_prod_prod$)
(declare-fun snth$g (Rule_state_rule_prod_prod_stream$ Nat$) Rule_state_rule_prod_prod$)
(declare-fun snth$h (Rule_rule_prod_rule_prod_stream$ Nat$) Rule_rule_prod_rule_prod$)
(declare-fun snth$i (Rule_rule_rule_prod_prod_stream$ Nat$) Rule_rule_rule_prod_prod$)
(declare-fun snth$j (State_rule_prod_rule_prod_stream$ Nat$) State_rule_prod_rule_prod$)
(declare-fun snth$k (State_rule_prod_state_prod_stream$ Nat$) State_rule_prod_state_prod$)
(declare-fun snth$l (State_rule_prod_state_rule_prod_prod_stream$ Nat$) State_rule_prod_state_rule_prod_prod$)
(declare-fun snth$m (Rule_state_state_prod_prod_stream$ Nat$) Rule_state_state_prod_prod$)
(declare-fun sset$a (Rule_rule_prod_stream$) Rule_rule_prod_set$)
(declare-fun sset$b (State_rule_prod_stream$) State_rule_prod_set$)
(declare-fun sset$c (State_stream$) State_set$)
(declare-fun szip$a (State_stream$ Rule_stream$) State_rule_prod_stream$)
(declare-fun szip$b (Rule_stream$ Rule_rule_prod_stream$) Rule_rule_rule_prod_prod_stream$)
(declare-fun szip$c (Rule_rule_prod_stream$ Rule_stream$) Rule_rule_prod_rule_prod_stream$)
(declare-fun szip$d (Rule_rule_prod_stream$ Rule_rule_prod_stream$) Rule_rule_prod_rule_rule_prod_prod_stream$)
(declare-fun szip$e (Rule_stream$ State_stream$) Rule_state_prod_stream$)
(declare-fun szip$f (State_stream$ State_stream$) State_state_prod_stream$)
(declare-fun szip$g (Rule_stream$ State_rule_prod_stream$) Rule_state_rule_prod_prod_stream$)
(declare-fun szip$h (Rule_rule_prod_stream$ State_stream$) Rule_rule_prod_state_prod_stream$)
(declare-fun szip$i (State_stream$ Rule_rule_prod_stream$) State_rule_rule_prod_prod_stream$)
(declare-fun szip$j (State_rule_prod_stream$ Rule_stream$) State_rule_prod_rule_prod_stream$)
(declare-fun szip$k (State_rule_prod_stream$ State_stream$) State_rule_prod_state_prod_stream$)
(declare-fun szip$l (State_stream$ State_rule_prod_stream$) State_state_rule_prod_prod_stream$)
(declare-fun szip$m (State_rule_prod_stream$ State_rule_prod_stream$) State_rule_prod_state_rule_prod_prod_stream$)
(declare-fun szip$n (Rule_stream$ State_state_prod_stream$) Rule_state_state_prod_prod_stream$)
(declare-fun member$ (State$ State_set$) Bool)
(declare-fun mkTree$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) State_rule_prod_tree$)
(declare-fun sdrop$a (Nat$ State_stream$) State_stream$)
(declare-fun sdrop$b (Nat$ State_rule_prod_stream$) State_rule_prod_stream$)
(declare-fun sdrop$c (Nat$ Rule_rule_prod_rule_rule_prod_prod_stream$) Rule_rule_prod_rule_rule_prod_prod_stream$)
(declare-fun sdrop$d (Nat$ Rule_rule_prod_rule_prod_stream$) Rule_rule_prod_rule_prod_stream$)
(declare-fun sdrop$e (Nat$ Rule_rule_rule_prod_prod_stream$) Rule_rule_rule_prod_prod_stream$)
(declare-fun sdrop$f (Nat$ Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-fun sdrop$g (Nat$ State_state_prod_stream$) State_state_prod_stream$)
(declare-fun sdrop$h (Nat$ Rule_state_prod_stream$) Rule_state_prod_stream$)
(declare-fun sdrop$i (Nat$ State_state_rule_prod_prod_stream$) State_state_rule_prod_prod_stream$)
(declare-fun sdrop$j (Nat$ Rule_state_rule_prod_prod_stream$) Rule_state_rule_prod_prod_stream$)
(declare-fun sdrop$k (Nat$ Rule_rule_prod_state_prod_stream$) Rule_rule_prod_state_prod_stream$)
(declare-fun sdrop$l (Nat$ State_rule_rule_prod_prod_stream$) State_rule_rule_prod_prod_stream$)
(declare-fun smap2$a (Rule_rule_rule_prod_rule_fun_fun$ Rule_stream$ Rule_rule_prod_stream$) Rule_stream$)
(declare-fun smap2$b (Rule_rule_prod_rule_rule_fun_fun$ Rule_rule_prod_stream$ Rule_stream$) Rule_stream$)
(declare-fun smap2$c (Rule_rule_rule_rule_prod_fun_fun$ Rule_stream$ Rule_stream$) Rule_rule_prod_stream$)
(declare-fun smap2$d (Rule_rule_prod_rule_rule_prod_rule_fun_fun$ Rule_rule_prod_stream$ Rule_rule_prod_stream$) Rule_stream$)
(declare-fun smap2$e (Rule_rule_rule_prod_rule_rule_prod_fun_fun$ Rule_stream$ Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-fun smap2$f (Rule_rule_prod_rule_rule_rule_prod_fun_fun$ Rule_rule_prod_stream$ Rule_stream$) Rule_rule_prod_stream$)
(declare-fun smap2$g (Rule_rule_prod_rule_rule_prod_rule_rule_prod_fun_fun$ Rule_rule_prod_stream$ Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-fun smap2$h (State_rule_rule_fun_fun$ State_stream$ Rule_stream$) Rule_stream$)
(declare-fun smap2$i (State_state_rule_fun_fun$ State_stream$ State_stream$) Rule_stream$)
(declare-fun smap2$j (Rule_state_rule_fun_fun$ Rule_stream$ State_stream$) Rule_stream$)
(declare-fun smap2$k (Rule_rule_state_fun_fun$ Rule_stream$ Rule_stream$) State_stream$)
(declare-fun smap2$l (Rule_state_state_fun_fun$ Rule_stream$ State_stream$) State_stream$)
(declare-fun smap2$m (State_rule_state_fun_fun$ State_stream$ Rule_stream$) State_stream$)
(declare-fun smap2$n (State_state_state_fun_fun$ State_stream$ State_stream$) State_stream$)
(declare-fun smap2$o (Rule_state_rule_prod_rule_fun_fun$ Rule_stream$ State_rule_prod_stream$) Rule_stream$)
(declare-fun smap2$p (State_rule_prod_rule_rule_fun_fun$ State_rule_prod_stream$ Rule_stream$) Rule_stream$)
(declare-fun enabled$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule$ State$) Bool)
(declare-fun fun_app$ (Nat_bool_fun$ Nat$) Bool)
(declare-fun member$a (Rule$ Rule_set$) Bool)
(declare-fun member$b (Rule_rule_prod$ Rule_rule_prod_set$) Bool)
(declare-fun member$c (State_rule_prod$ State_rule_prod_set$) Bool)
(declare-fun minWait$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) Nat$)
(declare-fun pickEff$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule$ State$) State_fset$)
(declare-fun fun_app$a (State_fset_bool_fun$ State_fset$) Bool)
(declare-fun fun_app$b (State_state_fset_bool_fun_fun$ State$) State_fset_bool_fun$)
(declare-fun fun_app$c (Rule_state_state_fset_bool_fun_fun_fun$ Rule$) State_state_fset_bool_fun_fun$)
(declare-fun fun_app$d (State_rule_fun$ State$) Rule$)
(declare-fun fun_app$e (Rule_state_rule_fun_fun$ Rule$) State_rule_fun$)
(declare-fun fun_app$f (Rule_rule_fun$ Rule$) Rule$)
(declare-fun fun_app$g (State_rule_rule_fun_fun$ State$) Rule_rule_fun$)
(declare-fun fun_app$h (State_state_rule_fun_fun$ State$) State_rule_fun$)
(declare-fun fun_app$i (Rule_state_fun$ Rule$) State$)
(declare-fun fun_app$j (Rule_rule_state_fun_fun$ Rule$) Rule_state_fun$)
(declare-fun fun_app$k (State_state_fun$ State$) State$)
(declare-fun fun_app$l (Rule_state_state_fun_fun$ Rule$) State_state_fun$)
(declare-fun fun_app$m (State_rule_state_fun_fun$ State$) Rule_state_fun$)
(declare-fun fun_app$n (State_state_state_fun_fun$ State$) State_state_fun$)
(declare-fun fun_app$o (Rule_rule_rule_fun_fun$ Rule$) Rule_rule_fun$)
(declare-fun fun_app$p (State_rule_prod_rule_fun$ State_rule_prod$) Rule$)
(declare-fun fun_app$q (Rule_state_rule_prod_rule_fun_fun$ Rule$) State_rule_prod_rule_fun$)
(declare-fun fun_app$r (State_rule_prod_rule_rule_fun_fun$ State_rule_prod$) Rule_rule_fun$)
(declare-fun saturated$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_stream$) Bool)
(declare-fun saturated$a (Rule_state_state_fset_bool_fun_fun_fun$ Rule$ State_rule_prod_stream$) Bool)
(assert (! (forall ((?v0 Rule_stream$) (?v1 State$) (?v2 Nat$)) (! (= (fun_app$ (uu$ ?v0 ?v1) ?v2) (enabled$ eff$ (shd$ (sdrop$ ?v2 ?v0)) ?v1)) :pattern ((fun_app$ (uu$ ?v0 ?v1) ?v2)))) :named a0))
(assert (! (not (exists ((?v0 Nat$)) (enabled$ eff$ (shd$ (sdrop$ ?v0 rs$)) s$))) :named a1))
(assert (! (enabled$ eff$ r$ s$) :named a2))
(assert (! (= (shd$ (sdrop$ n$ rs$)) r$) :named a3))
(assert (! (forall ((?v0 Rule$) (?v1 State$)) (! (= (enabled$ eff$ ?v0 ?v1) (exists ((?v2 State_fset$)) (fun_app$a (fun_app$b (fun_app$c eff$ ?v0) ?v1) ?v2))) :pattern ((enabled$ eff$ ?v0 ?v1)))) :named a4))
(assert (! (member$ s$ s$a) :named a5))
(assert (! (=> (forall ((?v0 Nat$)) (=> (= (shd$ (sdrop$ ?v0 rs$)) r$) false)) false) :named a6))
(assert (! (fair$ rules$ rs$) :named a7))
(assert (! (forall ((?v0 Rule$) (?v1 State$)) (=> (enabled$ eff$ ?v0 ?v1) (fun_app$a (fun_app$b (fun_app$c eff$ ?v0) ?v1) (pickEff$ eff$ ?v0 ?v1)))) :named a8))
(assert (! (=> (forall ((?v0 Rule$)) (=> (and (member$a ?v0 (sset$ rules$)) (enabled$ eff$ ?v0 s$)) false)) false) :named a9))
(assert (! (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 State$)) (! (= (enabled$ ?v0 ?v1 ?v2) (exists ((?v3 State_fset$)) (fun_app$a (fun_app$b (fun_app$c ?v0 ?v1) ?v2) ?v3))) :pattern ((enabled$ ?v0 ?v1 ?v2)))) :named a10))
(assert (! (forall ((?v0 Rule_stream$) (?v1 Nat$)) (=> (fair$ rules$ ?v0) (fair$ rules$ (sdrop$ ?v1 ?v0)))) :named a11))
(assert (! (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 State$)) (=> (enabled$ ?v0 ?v1 ?v2) (fun_app$a (fun_app$b (fun_app$c ?v0 ?v1) ?v2) (pickEff$ ?v0 ?v1 ?v2)))) :named a12))
(assert (! (forall ((?v0 State$)) (=> (member$ ?v0 s$a) (exists ((?v1 Rule$)) (and (member$a ?v1 (sset$ rules$)) (exists ((?v2 State_fset$)) (fun_app$a (fun_app$b (fun_app$c eff$ ?v1) ?v0) ?v2)))))) :named a13))
(assert (! (forall ((?v0 State_stream$) (?v1 State_stream$) (?v2 Nat$)) (=> (fair$a ?v0 ?v1) (fair$a ?v0 (sdrop$a ?v2 ?v1)))) :named a14))
(assert (! (forall ((?v0 State_rule_prod_stream$) (?v1 State_rule_prod_stream$) (?v2 Nat$)) (=> (fair$b ?v0 ?v1) (fair$b ?v0 (sdrop$b ?v2 ?v1)))) :named a15))
(assert (! (forall ((?v0 Rule_rule_prod_rule_rule_prod_prod_stream$) (?v1 Rule_rule_prod_rule_rule_prod_prod_stream$) (?v2 Nat$)) (=> (fair$c ?v0 ?v1) (fair$c ?v0 (sdrop$c ?v2 ?v1)))) :named a16))
(assert (! (forall ((?v0 Rule_rule_prod_rule_prod_stream$) (?v1 Rule_rule_prod_rule_prod_stream$) (?v2 Nat$)) (=> (fair$d ?v0 ?v1) (fair$d ?v0 (sdrop$d ?v2 ?v1)))) :named a17))
(assert (! (forall ((?v0 Rule_rule_rule_prod_prod_stream$) (?v1 Rule_rule_rule_prod_prod_stream$) (?v2 Nat$)) (=> (fair$e ?v0 ?v1) (fair$e ?v0 (sdrop$e ?v2 ?v1)))) :named a18))
(assert (! (forall ((?v0 Rule_rule_prod_stream$) (?v1 Rule_rule_prod_stream$) (?v2 Nat$)) (=> (fair$f ?v0 ?v1) (fair$f ?v0 (sdrop$f ?v2 ?v1)))) :named a19))
(assert (! (forall ((?v0 Rule_stream$) (?v1 Rule_stream$) (?v2 Nat$)) (=> (fair$ ?v0 ?v1) (fair$ ?v0 (sdrop$ ?v2 ?v1)))) :named a20))
(assert (! (forall ((?v0 State_rule_prod_stream$)) (= (saturated$ eff$ rules$ ?v0) (forall ((?v1 Rule$)) (=> (member$a ?v1 (sset$ rules$)) (saturated$a eff$ ?v1 ?v0))))) :named a21))
(assert (! (forall ((?v0 Rule_stream$) (?v1 State$)) (= (minWait$ eff$ ?v0 ?v1) (least$ (uu$ ?v0 ?v1)))) :named a22))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_stream$)) (= (shd$ (sdrop$ ?v0 ?v1)) (snth$ ?v1 ?v0))) :named a23))
(assert (! (forall ((?v0 Nat$) (?v1 State_stream$)) (= (shd$a (sdrop$a ?v0 ?v1)) (snth$a ?v1 ?v0))) :named a24))
(assert (! (forall ((?v0 Nat$) (?v1 State_rule_prod_stream$)) (= (shd$b (sdrop$b ?v0 ?v1)) (snth$b ?v1 ?v0))) :named a25))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_stream$)) (= (shd$f (sdrop$f ?v0 ?v1)) (snth$c ?v1 ?v0))) :named a26))
(assert (! (forall ((?v0 Nat$) (?v1 State_state_prod_stream$)) (= (shd$g (sdrop$g ?v0 ?v1)) (snth$d ?v1 ?v0))) :named a27))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_state_prod_stream$)) (= (shd$h (sdrop$h ?v0 ?v1)) (snth$e ?v1 ?v0))) :named a28))
(assert (! (forall ((?v0 Nat$) (?v1 State_state_rule_prod_prod_stream$)) (= (shd$i (sdrop$i ?v0 ?v1)) (snth$f ?v1 ?v0))) :named a29))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_state_rule_prod_prod_stream$)) (= (shd$j (sdrop$j ?v0 ?v1)) (snth$g ?v1 ?v0))) :named a30))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_rule_prod_stream$)) (= (shd$d (sdrop$d ?v0 ?v1)) (snth$h ?v1 ?v0))) :named a31))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_rule_prod_prod_stream$)) (= (shd$e (sdrop$e ?v0 ?v1)) (snth$i ?v1 ?v0))) :named a32))
(assert (! (forall ((?v0 Rule_rule_prod_stream$)) (member$b (shd$f ?v0) (sset$a ?v0))) :named a33))
(assert (! (forall ((?v0 State_rule_prod_stream$)) (member$c (shd$b ?v0) (sset$b ?v0))) :named a34))
(assert (! (forall ((?v0 State_stream$)) (member$ (shd$a ?v0) (sset$c ?v0))) :named a35))
(assert (! (forall ((?v0 Rule_stream$)) (member$a (shd$ ?v0) (sset$ ?v0))) :named a36))
(assert (! (forall ((?v0 State$) (?v1 Rule_stream$)) (! (=> (and (member$ ?v0 s$a) (fair$ rules$ ?v1)) (= (trim$ eff$ ?v1 ?v0) (sdrop$ (minWait$ eff$ ?v1 ?v0) ?v1))) :pattern ((trim$ eff$ ?v1 ?v0)))) :named a37))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 Rule_stream$)) (= (sdrop$f ?v0 (szip$ ?v1 ?v2)) (szip$ (sdrop$ ?v0 ?v1) (sdrop$ ?v0 ?v2)))) :named a38))
(assert (! (forall ((?v0 Nat$) (?v1 State_stream$) (?v2 Rule_stream$)) (= (sdrop$b ?v0 (szip$a ?v1 ?v2)) (szip$a (sdrop$a ?v0 ?v1) (sdrop$ ?v0 ?v2)))) :named a39))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 Rule_rule_prod_stream$)) (= (sdrop$e ?v0 (szip$b ?v1 ?v2)) (szip$b (sdrop$ ?v0 ?v1) (sdrop$f ?v0 ?v2)))) :named a40))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_stream$) (?v2 Rule_stream$)) (= (sdrop$d ?v0 (szip$c ?v1 ?v2)) (szip$c (sdrop$f ?v0 ?v1) (sdrop$ ?v0 ?v2)))) :named a41))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_stream$) (?v2 Rule_rule_prod_stream$)) (= (sdrop$c ?v0 (szip$d ?v1 ?v2)) (szip$d (sdrop$f ?v0 ?v1) (sdrop$f ?v0 ?v2)))) :named a42))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 State_stream$)) (= (sdrop$h ?v0 (szip$e ?v1 ?v2)) (szip$e (sdrop$ ?v0 ?v1) (sdrop$a ?v0 ?v2)))) :named a43))
(assert (! (forall ((?v0 Nat$) (?v1 State_stream$) (?v2 State_stream$)) (= (sdrop$g ?v0 (szip$f ?v1 ?v2)) (szip$f (sdrop$a ?v0 ?v1) (sdrop$a ?v0 ?v2)))) :named a44))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 State_rule_prod_stream$)) (= (sdrop$j ?v0 (szip$g ?v1 ?v2)) (szip$g (sdrop$ ?v0 ?v1) (sdrop$b ?v0 ?v2)))) :named a45))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_stream$) (?v2 State_stream$)) (= (sdrop$k ?v0 (szip$h ?v1 ?v2)) (szip$h (sdrop$f ?v0 ?v1) (sdrop$a ?v0 ?v2)))) :named a46))
(assert (! (forall ((?v0 Nat$) (?v1 State_stream$) (?v2 Rule_rule_prod_stream$)) (= (sdrop$l ?v0 (szip$i ?v1 ?v2)) (szip$i (sdrop$a ?v0 ?v1) (sdrop$f ?v0 ?v2)))) :named a47))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_rule_fun_fun$) (?v2 Rule_stream$) (?v3 Rule_stream$)) (= (sdrop$ ?v0 (smap2$ ?v1 ?v2 ?v3)) (smap2$ ?v1 (sdrop$ ?v0 ?v2) (sdrop$ ?v0 ?v3)))) :named a48))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_rule_prod_rule_fun_fun$) (?v2 Rule_stream$) (?v3 Rule_rule_prod_stream$)) (= (sdrop$ ?v0 (smap2$a ?v1 ?v2 ?v3)) (smap2$a ?v1 (sdrop$ ?v0 ?v2) (sdrop$f ?v0 ?v3)))) :named a49))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_rule_rule_fun_fun$) (?v2 Rule_rule_prod_stream$) (?v3 Rule_stream$)) (= (sdrop$ ?v0 (smap2$b ?v1 ?v2 ?v3)) (smap2$b ?v1 (sdrop$f ?v0 ?v2) (sdrop$ ?v0 ?v3)))) :named a50))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_rule_rule_prod_fun_fun$) (?v2 Rule_stream$) (?v3 Rule_stream$)) (= (sdrop$f ?v0 (smap2$c ?v1 ?v2 ?v3)) (smap2$c ?v1 (sdrop$ ?v0 ?v2) (sdrop$ ?v0 ?v3)))) :named a51))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_rule_rule_prod_rule_fun_fun$) (?v2 Rule_rule_prod_stream$) (?v3 Rule_rule_prod_stream$)) (= (sdrop$ ?v0 (smap2$d ?v1 ?v2 ?v3)) (smap2$d ?v1 (sdrop$f ?v0 ?v2) (sdrop$f ?v0 ?v3)))) :named a52))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_rule_prod_rule_rule_prod_fun_fun$) (?v2 Rule_stream$) (?v3 Rule_rule_prod_stream$)) (= (sdrop$f ?v0 (smap2$e ?v1 ?v2 ?v3)) (smap2$e ?v1 (sdrop$ ?v0 ?v2) (sdrop$f ?v0 ?v3)))) :named a53))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_rule_rule_rule_prod_fun_fun$) (?v2 Rule_rule_prod_stream$) (?v3 Rule_stream$)) (= (sdrop$f ?v0 (smap2$f ?v1 ?v2 ?v3)) (smap2$f ?v1 (sdrop$f ?v0 ?v2) (sdrop$ ?v0 ?v3)))) :named a54))
(assert (! (forall ((?v0 Nat$) (?v1 Rule_rule_prod_rule_rule_prod_rule_rule_prod_fun_fun$) (?v2 Rule_rule_prod_stream$) (?v3 Rule_rule_prod_stream$)) (= (sdrop$f ?v0 (smap2$g ?v1 ?v2 ?v3)) (smap2$g ?v1 (sdrop$f ?v0 ?v2) (sdrop$f ?v0 ?v3)))) :named a55))
(assert (! (forall ((?v0 Nat$) (?v1 State_rule_rule_fun_fun$) (?v2 State_stream$) (?v3 Rule_stream$)) (= (sdrop$ ?v0 (smap2$h ?v1 ?v2 ?v3)) (smap2$h ?v1 (sdrop$a ?v0 ?v2) (sdrop$ ?v0 ?v3)))) :named a56))
(assert (! (forall ((?v0 Nat$) (?v1 State_state_rule_fun_fun$) (?v2 State_stream$) (?v3 State_stream$)) (= (sdrop$ ?v0 (smap2$i ?v1 ?v2 ?v3)) (smap2$i ?v1 (sdrop$a ?v0 ?v2) (sdrop$a ?v0 ?v3)))) :named a57))
(assert (! (forall ((?v0 Rule_stream$) (?v1 State$)) (= (root$ (mkTree$ eff$ ?v0 ?v1)) (pair$ ?v1 (shd$ (trim$ eff$ ?v0 ?v1))))) :named a58))
(assert (! (member$a r$ (sset$ rules$)) :named a59))
(assert (! (forall ((?v0 Rule_state_rule_fun_fun$) (?v1 Rule_stream$) (?v2 State_stream$) (?v3 Nat$)) (= (snth$ (smap2$j ?v0 ?v1 ?v2) ?v3) (fun_app$d (fun_app$e ?v0 (snth$ ?v1 ?v3)) (snth$a ?v2 ?v3)))) :named a60))
(assert (! (forall ((?v0 State_rule_rule_fun_fun$) (?v1 State_stream$) (?v2 Rule_stream$) (?v3 Nat$)) (= (snth$ (smap2$h ?v0 ?v1 ?v2) ?v3) (fun_app$f (fun_app$g ?v0 (snth$a ?v1 ?v3)) (snth$ ?v2 ?v3)))) :named a61))
(assert (! (forall ((?v0 State_state_rule_fun_fun$) (?v1 State_stream$) (?v2 State_stream$) (?v3 Nat$)) (= (snth$ (smap2$i ?v0 ?v1 ?v2) ?v3) (fun_app$d (fun_app$h ?v0 (snth$a ?v1 ?v3)) (snth$a ?v2 ?v3)))) :named a62))
(assert (! (forall ((?v0 Rule_rule_state_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_stream$) (?v3 Nat$)) (= (snth$a (smap2$k ?v0 ?v1 ?v2) ?v3) (fun_app$i (fun_app$j ?v0 (snth$ ?v1 ?v3)) (snth$ ?v2 ?v3)))) :named a63))
(assert (! (forall ((?v0 Rule_state_state_fun_fun$) (?v1 Rule_stream$) (?v2 State_stream$) (?v3 Nat$)) (= (snth$a (smap2$l ?v0 ?v1 ?v2) ?v3) (fun_app$k (fun_app$l ?v0 (snth$ ?v1 ?v3)) (snth$a ?v2 ?v3)))) :named a64))
(assert (! (forall ((?v0 State_rule_state_fun_fun$) (?v1 State_stream$) (?v2 Rule_stream$) (?v3 Nat$)) (= (snth$a (smap2$m ?v0 ?v1 ?v2) ?v3) (fun_app$i (fun_app$m ?v0 (snth$a ?v1 ?v3)) (snth$ ?v2 ?v3)))) :named a65))
(assert (! (forall ((?v0 State_state_state_fun_fun$) (?v1 State_stream$) (?v2 State_stream$) (?v3 Nat$)) (= (snth$a (smap2$n ?v0 ?v1 ?v2) ?v3) (fun_app$k (fun_app$n ?v0 (snth$a ?v1 ?v3)) (snth$a ?v2 ?v3)))) :named a66))
(assert (! (forall ((?v0 Rule_rule_rule_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_stream$) (?v3 Nat$)) (= (snth$ (smap2$ ?v0 ?v1 ?v2) ?v3) (fun_app$f (fun_app$o ?v0 (snth$ ?v1 ?v3)) (snth$ ?v2 ?v3)))) :named a67))
(assert (! (forall ((?v0 Rule_state_rule_prod_rule_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_stream$) (?v3 Nat$)) (= (snth$ (smap2$o ?v0 ?v1 ?v2) ?v3) (fun_app$p (fun_app$q ?v0 (snth$ ?v1 ?v3)) (snth$b ?v2 ?v3)))) :named a68))
(assert (! (forall ((?v0 State_rule_prod_rule_rule_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_stream$) (?v3 Nat$)) (= (snth$ (smap2$p ?v0 ?v1 ?v2) ?v3) (fun_app$f (fun_app$r ?v0 (snth$b ?v1 ?v3)) (snth$ ?v2 ?v3)))) :named a69))
(assert (! (forall ((?v0 State_stream$) (?v1 Rule_stream$) (?v2 Nat$)) (= (snth$b (szip$a ?v0 ?v1) ?v2) (pair$ (snth$a ?v0 ?v2) (snth$ ?v1 ?v2)))) :named a70))
(assert (! (forall ((?v0 Rule_stream$) (?v1 State_stream$) (?v2 Nat$)) (= (snth$e (szip$e ?v0 ?v1) ?v2) (pair$f (snth$ ?v0 ?v2) (snth$a ?v1 ?v2)))) :named a71))
(assert (! (forall ((?v0 State_stream$) (?v1 State_stream$) (?v2 Nat$)) (= (snth$d (szip$f ?v0 ?v1) ?v2) (pair$e (snth$a ?v0 ?v2) (snth$a ?v1 ?v2)))) :named a72))
(assert (! (forall ((?v0 Rule_stream$) (?v1 Rule_stream$) (?v2 Nat$)) (= (snth$c (szip$ ?v0 ?v1) ?v2) (pair$a (snth$ ?v0 ?v2) (snth$ ?v1 ?v2)))) :named a73))
(assert (! (forall ((?v0 Rule_stream$) (?v1 State_rule_prod_stream$) (?v2 Nat$)) (= (snth$g (szip$g ?v0 ?v1) ?v2) (pair$h (snth$ ?v0 ?v2) (snth$b ?v1 ?v2)))) :named a74))
(assert (! (forall ((?v0 State_rule_prod_stream$) (?v1 Rule_stream$) (?v2 Nat$)) (= (snth$j (szip$j ?v0 ?v1) ?v2) (pair$k (snth$b ?v0 ?v2) (snth$ ?v1 ?v2)))) :named a75))
(assert (! (forall ((?v0 State_rule_prod_stream$) (?v1 State_stream$) (?v2 Nat$)) (= (snth$k (szip$k ?v0 ?v1) ?v2) (pair$l (snth$b ?v0 ?v2) (snth$a ?v1 ?v2)))) :named a76))
(assert (! (forall ((?v0 State_stream$) (?v1 State_rule_prod_stream$) (?v2 Nat$)) (= (snth$f (szip$l ?v0 ?v1) ?v2) (pair$g (snth$a ?v0 ?v2) (snth$b ?v1 ?v2)))) :named a77))
(assert (! (forall ((?v0 State_rule_prod_stream$) (?v1 State_rule_prod_stream$) (?v2 Nat$)) (= (snth$l (szip$m ?v0 ?v1) ?v2) (pair$m (snth$b ?v0 ?v2) (snth$b ?v1 ?v2)))) :named a78))
(assert (! (forall ((?v0 Rule_stream$) (?v1 State_state_prod_stream$) (?v2 Nat$)) (= (snth$m (szip$n ?v0 ?v1) ?v2) (pair$n (snth$ ?v0 ?v2) (snth$d ?v1 ?v2)))) :named a79))
(check-sat)
;(get-unsat-core)
