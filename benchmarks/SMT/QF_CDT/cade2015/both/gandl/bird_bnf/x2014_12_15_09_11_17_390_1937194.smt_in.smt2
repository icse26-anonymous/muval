; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --random-seed=1 --lang=smt2 --tlimit 492
;(set-option :produce-unsat-cores true)
(set-logic ALL_SUPPORTED)
(declare-sort Nat$ 0)
(declare-sort Nat_nat_nat_prod_fun$ 0)
(declare-sort Nat_nat_nat_nat_prod_fun_fun$ 0)
(declare-sort Nat_nat_prod_nat_nat_prod_fun$ 0)
(declare-sort Nat_nat_prod_nat_nat_prod_fun_nat_nat_prod_nat_nat_prod_fun_fun$ 0)
(declare-datatypes () ((Nat_nat_prod$ (pair$ (fst$ Nat$) (snd$ Nat$)))))
(declare-codatatypes () ((Nat_nat_prod_tree$ (node$ (root$ Nat_nat_prod$) (left$ Nat_nat_prod_tree$) (right$ Nat_nat_prod_tree$)))))
(declare-datatypes () ((Num$ (one$) (bit0$ (select$ Num$)) (bit1$ (selecta$ Num$)))))
(declare-fun uu$ () Nat_nat_nat_nat_prod_fun_fun$)
(declare-fun uua$ () Nat_nat_nat_nat_prod_fun_fun$)
(declare-fun uub$ () Nat_nat_nat_nat_prod_fun_fun$)
(declare-fun bird$ () Nat_nat_prod_tree$)
(declare-fun comp$ (Nat_nat_prod_nat_nat_prod_fun$) Nat_nat_prod_nat_nat_prod_fun_nat_nat_prod_nat_nat_prod_fun_fun$)
(declare-fun one$a () Nat$)
(declare-fun plus$ (Nat$ Nat$) Nat$)
(declare-fun plus$a (Num$ Num$) Num$)
(declare-fun fun_app$ (Nat_nat_nat_prod_fun$ Nat$) Nat_nat_prod$)
(declare-fun numeral$ (Num$) Nat$)
(declare-fun fun_app$a (Nat_nat_nat_nat_prod_fun_fun$ Nat$) Nat_nat_nat_prod_fun$)
(declare-fun fun_app$b (Nat_nat_prod_nat_nat_prod_fun_nat_nat_prod_nat_nat_prod_fun_fun$ Nat_nat_prod_nat_nat_prod_fun$) Nat_nat_prod_nat_nat_prod_fun$)
(declare-fun map_tree$ (Nat_nat_prod_nat_nat_prod_fun$ Nat_nat_prod_tree$) Nat_nat_prod_tree$)
(declare-fun case_prod$ (Nat_nat_nat_nat_prod_fun_fun$) Nat_nat_prod_nat_nat_prod_fun$)
(declare-fun odd_mirror$ (Nat_nat_prod_tree$) Nat_nat_prod_tree$)
(declare-fun intermediate$ (Nat_nat_prod_tree$) Nat_nat_prod_tree$)
(assert (! (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$ (fun_app$a uua$ ?v0) ?v1) (pair$ (plus$ ?v0 ?v1) ?v1)) :pattern ((fun_app$ (fun_app$a uua$ ?v0) ?v1)))) :named a0))
(assert (! (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$ (fun_app$a uub$ ?v0) ?v1) (pair$ ?v0 (plus$ ?v0 ?v1))) :pattern ((fun_app$ (fun_app$a uub$ ?v0) ?v1)))) :named a1))
(assert (! (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$ (fun_app$a uu$ ?v0) ?v1) (pair$ ?v1 ?v0)) :pattern ((fun_app$ (fun_app$a uu$ ?v0) ?v1)))) :named a2))
(assert (! (not (= (odd_mirror$ bird$) (node$ (pair$ one$a one$a) (node$ (pair$ one$a (numeral$ (bit0$ one$))) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uua$))) (case_prod$ uu$)) (odd_mirror$ bird$)) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uu$))) (case_prod$ uua$)) (odd_mirror$ bird$))) (node$ (pair$ (numeral$ (bit0$ one$)) one$a) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uu$))) (case_prod$ uua$))) (case_prod$ uu$)) (odd_mirror$ bird$)) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uu$))) (case_prod$ uu$))) (case_prod$ uua$)) (odd_mirror$ bird$)))))) :named a3))
(assert (! (= (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uu$))) (case_prod$ uu$))) (case_prod$ uua$))) (case_prod$ uu$)) (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uua$))) (case_prod$ uu$))) :named a4))
(assert (! (= (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uu$))) (case_prod$ uu$))) (case_prod$ uua$)) (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uua$))) :named a5))
(assert (! (forall ((?v0 Nat_nat_prod_nat_nat_prod_fun$) (?v1 Nat_nat_prod_tree$)) (= (map_tree$ ?v0 (odd_mirror$ ?v1)) (odd_mirror$ (map_tree$ ?v0 ?v1)))) :named a6))
(assert (! (forall ((?v0 Nat_nat_prod_tree$)) (= (intermediate$ ?v0) (node$ (pair$ one$a one$a) (node$ (pair$ one$a (numeral$ (bit0$ one$))) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uua$))) (case_prod$ uu$)) ?v0) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uu$))) (case_prod$ uua$)) ?v0)) (node$ (pair$ (numeral$ (bit0$ one$)) one$a) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uu$))) (case_prod$ uua$))) (case_prod$ uu$)) ?v0) (map_tree$ (fun_app$b (comp$ (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uua$)) (case_prod$ uu$))) (case_prod$ uu$))) (case_prod$ uua$)) ?v0))))) :named a7))
(assert (! (= (plus$ one$a one$a) (numeral$ (bit0$ one$))) :named a8))
(assert (! (forall ((?v0 Num$)) (= (plus$ (numeral$ ?v0) one$a) (numeral$ (plus$a ?v0 one$)))) :named a9))
(assert (! (forall ((?v0 Num$)) (= (plus$ one$a (numeral$ ?v0)) (numeral$ (plus$a one$ ?v0)))) :named a10))
(assert (! (forall ((?v0 Num$)) (= (= (numeral$ ?v0) one$a) (= ?v0 one$))) :named a11))
(assert (! (forall ((?v0 Num$)) (= (= one$a (numeral$ ?v0)) (= one$ ?v0))) :named a12))
(assert (! (= (plus$ one$a one$a) (numeral$ (bit0$ one$))) :named a13))
(assert (! (forall ((?v0 Num$)) (= (= (bit0$ ?v0) one$) false)) :named a14))
(assert (! (forall ((?v0 Num$)) (= (= one$ (bit0$ ?v0)) false)) :named a15))
(assert (! (forall ((?v0 Num$) (?v1 Num$) (?v2 Nat$)) (= (plus$ (numeral$ ?v0) (plus$ (numeral$ ?v1) ?v2)) (plus$ (numeral$ (plus$a ?v0 ?v1)) ?v2))) :named a16))
(assert (! (forall ((?v0 Num$) (?v1 Num$)) (= (plus$ (numeral$ ?v0) (numeral$ ?v1)) (numeral$ (plus$a ?v0 ?v1)))) :named a17))
(assert (! (= (fun_app$b (comp$ (fun_app$b (comp$ (case_prod$ uu$)) (case_prod$ uua$))) (case_prod$ uu$)) (case_prod$ uub$)) :named a18))
(assert (! (forall ((?v0 Num$) (?v1 Num$)) (= (= (numeral$ ?v0) (numeral$ ?v1)) (= ?v0 ?v1))) :named a19))
(check-sat)
;(get-unsat-core)
