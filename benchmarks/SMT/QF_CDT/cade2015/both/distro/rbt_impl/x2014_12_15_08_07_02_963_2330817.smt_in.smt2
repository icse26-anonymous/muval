; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --random-seed=1 --lang=smt2 --tlimit 86
;(set-option :produce-unsat-cores true)
(set-logic ALL_SUPPORTED)
(declare-sort A$ 0)
(declare-sort B$ 0)
(declare-sort A_set$ 0)
(declare-sort A_b_prod_set$ 0)
(declare-sort A_b_prod_bool_fun$ 0)
(declare-datatypes () ((A_b_prod$ (pair$ (fst$ A$) (snd$ B$)))
  (A_b_prod_list$ (nil$) (cons$ (hd$ A_b_prod$) (tl$ A_b_prod_list$)))
  (Color$ (r$) (b$))
  (A_b_rbt$ (empty$) (branch$ (select$ Color$) (selecta$ A_b_rbt$) (selectb$ A$) (selectc$ B$) (selectd$ A_b_rbt$)))
  (A_list$ (nil$a) (cons$a (hd$a A$) (tl$a A_list$)))))
(declare-fun k$ () A$)
(declare-fun l$ () A_b_rbt$)
(declare-fun v$ () A$)
(declare-fun x$ () B$)
(declare-fun y$ () B$)
(declare-fun r$a () A_b_rbt$)
(declare-fun set$ (A_b_prod_list$) A_b_prod_set$)
(declare-fun keys$ (A_b_rbt$) A_list$)
(declare-fun set$a (A_list$) A_set$)
(declare-fun member$ (A_b_prod$ A_b_prod_set$) Bool)
(declare-fun balance$ (A_b_rbt$ A$ B$ A_b_rbt$) A_b_rbt$)
(declare-fun entries$ (A_b_rbt$) A_b_prod_list$)
(declare-fun fun_app$ (A_b_prod_bool_fun$ A_b_prod$) Bool)
(declare-fun member$a (A$ A_set$) Bool)
(assert (! (not (= (member$ (pair$ k$ x$) (set$ (entries$ (balance$ l$ v$ y$ r$a)))) (or (member$ (pair$ k$ x$) (set$ (entries$ l$))) (or (and (= k$ v$) (= x$ y$)) (member$ (pair$ k$ x$) (set$ (entries$ r$a))))))) :named a0))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A$) (?v3 B$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a1))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A$) (?v3 B$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a2))
(assert (! (forall ((?v0 A$) (?v1 A_b_rbt$)) (= (member$a ?v0 (set$a (keys$ ?v1))) (exists ((?v2 B$)) (member$ (pair$ ?v0 ?v2) (set$ (entries$ ?v1)))))) :named a3))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A_b_rbt$)) (=> (member$ (pair$ ?v0 ?v1) (set$ (entries$ ?v2))) (member$a ?v0 (set$a (keys$ ?v2))))) :named a4))
(assert (! (forall ((?v0 A_b_prod$)) (=> (forall ((?v1 A$) (?v2 B$)) (=> (= ?v0 (pair$ ?v1 ?v2)) false)) false)) :named a5))
(assert (! (forall ((?v0 A_b_prod$)) (exists ((?v1 A$) (?v2 B$)) (= ?v0 (pair$ ?v1 ?v2)))) :named a6))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A$) (?v3 B$)) (=> (and (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (=> (and (= ?v0 ?v2) (= ?v1 ?v3)) false)) false)) :named a7))
(assert (! (forall ((?v0 A_b_prod$)) (=> (forall ((?v1 A$) (?v2 B$)) (=> (= ?v0 (pair$ ?v1 ?v2)) false)) false)) :named a8))
(assert (! (forall ((?v0 A_b_prod_bool_fun$) (?v1 A_b_prod$)) (=> (forall ((?v2 A$) (?v3 B$)) (fun_app$ ?v0 (pair$ ?v2 ?v3))) (fun_app$ ?v0 ?v1))) :named a9))
(check-sat)
;(get-unsat-core)
