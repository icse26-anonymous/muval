; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --random-seed=1 --lang=smt2 --tlimit 154
;(set-option :produce-unsat-cores true)
(set-logic ALL_SUPPORTED)
(declare-sort A$ 0)
(declare-sort B$ 0)
(declare-sort Nat$ 0)
(declare-sort A_set$ 0)
(declare-sort A_b_prod_set$ 0)
(declare-datatypes () ((A_b_prod$ (pair$ (fst$ A$) (snd$ B$)))
  (A_b_prod_list$ (nil$) (cons$ (hd$ A_b_prod$) (tl$ A_b_prod_list$)))
  (Color$ (r$) (b$))
  (A_b_rbt$ (empty$) (branch$ (select$ Color$) (selecta$ A_b_rbt$) (selectb$ A$) (selectc$ B$) (selectd$ A_b_rbt$)))
  (A_list$ (nil$a) (cons$a (hd$a A$) (tl$a A_list$)))))
(declare-fun k$ () A$)
(declare-fun l$ () A_b_rbt$)
(declare-fun v$ () B$)
(declare-fun r$a () A_b_rbt$)
(declare-fun set$ (A_b_prod_list$) A_b_prod_set$)
(declare-fun inv1$ (A_b_rbt$) Bool)
(declare-fun inv2$ (A_b_rbt$) Bool)
(declare-fun keys$ (A_b_rbt$) A_list$)
(declare-fun set$a (A_list$) A_set$)
(declare-fun paint$ (Color$ A_b_rbt$) A_b_rbt$)
(declare-fun member$ (A_b_prod$ A_b_prod_set$) Bool)
(declare-fun balance$ (A_b_rbt$ A$ B$ A_b_rbt$) A_b_rbt$)
(declare-fun bheight$ (A_b_rbt$) Nat$)
(declare-fun combine$ (A_b_rbt$ A_b_rbt$) A_b_rbt$)
(declare-fun entries$ (A_b_rbt$) A_b_prod_list$)
(declare-fun member$a (A$ A_set$) Bool)
(assert (! (not (= (member$ (pair$ k$ v$) (set$ (entries$ (combine$ l$ r$a)))) (or (member$ (pair$ k$ v$) (set$ (entries$ l$))) (member$ (pair$ k$ v$) (set$ (entries$ r$a)))))) :named a0))
(assert (! (inv1$ l$) :named a1))
(assert (! (inv1$ r$a) :named a2))
(assert (! (inv2$ l$) :named a3))
(assert (! (inv2$ r$a) :named a4))
(assert (! (= (bheight$ l$) (bheight$ r$a)) :named a5))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A$) (?v3 B$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a6))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A$) (?v3 B$)) (= (= (pair$ ?v0 ?v1) (pair$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3)))) :named a7))
(assert (! (forall ((?v0 A$) (?v1 A_b_rbt$)) (= (member$a ?v0 (set$a (keys$ ?v1))) (exists ((?v2 B$)) (member$ (pair$ ?v0 ?v2) (set$ (entries$ ?v1)))))) :named a8))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A_b_rbt$)) (=> (member$ (pair$ ?v0 ?v1) (set$ (entries$ ?v2))) (member$a ?v0 (set$a (keys$ ?v2))))) :named a9))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 Color$) (?v3 A_b_rbt$)) (= (member$ (pair$ ?v0 ?v1) (set$ (entries$ (paint$ ?v2 ?v3)))) (member$ (pair$ ?v0 ?v1) (set$ (entries$ ?v3))))) :named a10))
(assert (! (forall ((?v0 A_b_rbt$) (?v1 A_b_rbt$)) (=> (and (inv2$ ?v0) (and (inv2$ ?v1) (= (bheight$ ?v0) (bheight$ ?v1)))) (= (bheight$ (combine$ ?v0 ?v1)) (bheight$ ?v0)))) :named a11))
(assert (! (forall ((?v0 A_b_rbt$) (?v1 A_b_rbt$)) (=> (and (inv2$ ?v0) (and (inv2$ ?v1) (= (bheight$ ?v0) (bheight$ ?v1)))) (inv2$ (combine$ ?v0 ?v1)))) :named a12))
(assert (! (forall ((?v0 A$) (?v1 B$) (?v2 A_b_rbt$) (?v3 A$) (?v4 B$) (?v5 A_b_rbt$)) (= (member$ (pair$ ?v0 ?v1) (set$ (entries$ (balance$ ?v2 ?v3 ?v4 ?v5)))) (or (member$ (pair$ ?v0 ?v1) (set$ (entries$ ?v2))) (or (and (= ?v0 ?v3) (= ?v1 ?v4)) (member$ (pair$ ?v0 ?v1) (set$ (entries$ ?v5))))))) :named a13))
(assert (! (forall ((?v0 A_b_prod$)) (=> (forall ((?v1 A$) (?v2 B$)) (=> (= ?v0 (pair$ ?v1 ?v2)) false)) false)) :named a14))
(check-sat)
;(get-unsat-core)
