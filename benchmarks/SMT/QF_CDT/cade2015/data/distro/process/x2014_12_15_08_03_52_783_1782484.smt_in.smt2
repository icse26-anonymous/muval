;(set-option :produce-unsat-cores true )
(set-logic ALL_SUPPORTED )
(declare-sort A$ 0 )
(declare-sort B$ 0 )
(declare-sort C$ 0 )
(declare-sort A_bool_fun$ 0 )
(declare-sort B_bool_fun$ 0 )
(declare-sort C_bool_fun$ 0 )
(declare-sort A_b_a_process_term_fun$ 0 )
(declare-sort B_process$ 0)
(declare-fun prefOf$ (B_process$)B$)
(declare-fun contOf$ (B_process$)B_process$)
(declare-fun action$ (B$ B_process$ )B_process$)
(declare-fun ch1Of$ (B_process$)B_process$)
(declare-fun ch2Of$ (B_process$)B_process$)
(declare-fun choice$ (B_process$ B_process$ )B_process$)
(declare-datatypes ()((B_a_process_term$ (var$ (select$ A$ ))(proc$ (selecta$ B_process$ ))(act$ (selectb$ B$ )(selectc$ B_a_process_term$ ))(ch$ (selectd$ B_a_process_term$ )(selecte$ B_a_process_term$ )))))
(declare-sort C_process$ 0)
(declare-fun prefOf$a (C_process$)C$)
(declare-fun contOf$a (C_process$)C_process$)
(declare-fun action$a (C$ C_process$ )C_process$)
(declare-fun ch1Of$a (C_process$)C_process$)
(declare-fun ch2Of$a (C_process$)C_process$)
(declare-fun choice$a (C_process$ C_process$ )C_process$)
(declare-datatypes ()((C_a_process_term$ (var$a (selectf$ A$ ))(proc$a (selectg$ C_process$ ))(act$a (selecth$ C$ )(selecti$ C_a_process_term$ ))(ch$a (selectj$ C_a_process_term$ )(selectk$ C_a_process_term$ )))))
(declare-fun x$ ()A$ )
(declare-fun cH1$ (A_b_a_process_term_fun$ B_a_process_term$ )B_a_process_term$ )
(declare-fun cH2$ (A_b_a_process_term_fun$ B_a_process_term$ )B_a_process_term$ )
(declare-fun sys$ ()A_b_a_process_term_fun$ )
(declare-fun cont$ (A_b_a_process_term_fun$ B_a_process_term$ )B_a_process_term$ )
(declare-fun pref$ (A_b_a_process_term_fun$ B_a_process_term$ )B$ )
(declare-fun isACT$ (A_b_a_process_term_fun$ C_a_process_term$ )Bool )
(declare-fun isACT$a (A_b_a_process_term_fun$ B_a_process_term$ )Bool )
(declare-fun fun_app$ (A_b_a_process_term_fun$ A$ )B_a_process_term$ )
(declare-fun guarded$ (A_b_a_process_term_fun$ )Bool )
(declare-fun fun_app$a (B_bool_fun$ B$ )Bool )
(declare-fun fun_app$b (A_bool_fun$ A$ )Bool )
(declare-fun solution$ (A_b_a_process_term_fun$ B_a_process_term$ )B_process$ )
(declare-fun pred_process$ (B_bool_fun$ B_process$ )Bool )
(declare-fun pred_process_term$ (B_bool_fun$ A_bool_fun$ B_a_process_term$ )Bool )
(declare-fun pred_process_term$a (C_bool_fun$ A_bool_fun$ C_a_process_term$ )Bool )
(assert (! (not (= (solution$ sys$ (var$ x$ ))(action$ (pref$ sys$ (fun_app$ sys$ x$ ))(solution$ sys$ (cont$ sys$ (fun_app$ sys$ x$ )))))):named a0 ))
(assert (! (guarded$ sys$ ):named a1 ))
(assert (! (isACT$ sys$ (var$a x$ )):named a2 ))
(assert (! (forall ((?v0 A$ )(?v1 A$ ))(= (= (var$ ?v0 )(var$ ?v1 ))(= ?v0 ?v1 ))):named a3 ))
(assert (! (forall ((?v0 A$ )(?v1 A$ ))(= (= (var$a ?v0 )(var$a ?v1 ))(= ?v0 ?v1 ))):named a4 ))
(assert (! (forall ((?v0 B$ )(?v1 B_process$ )(?v2 B$ )(?v3 B_process$ ))(= (= (action$ ?v0 ?v1 )(action$ ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a5 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 B_a_process_term$ ))(=> (isACT$a ?v0 ?v1 )(= (solution$ ?v0 ?v1 )(action$ (pref$ ?v0 ?v1 )(solution$ ?v0 (cont$ ?v0 ?v1 )))))):named a6 ))
(assert (! (isACT$a sys$ (fun_app$ sys$ x$ )):named a7 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ ))(= (guarded$ ?v0 )(forall ((?v1 A$ )(?v2 A$ ))(not (= (fun_app$ ?v0 ?v1 )(var$ ?v2 )))))):named a8 ))
(assert (! (forall ((?v0 B_bool_fun$ )(?v1 B$ )(?v2 B_process$ ))(! (= (pred_process$ ?v0 (action$ ?v1 ?v2 ))(and (fun_app$a ?v0 ?v1 )(pred_process$ ?v0 ?v2 ))):pattern ((pred_process$ ?v0 (action$ ?v1 ?v2 ))))):named a9 ))
(assert (! (forall ((?v0 B_bool_fun$ )(?v1 A_bool_fun$ )(?v2 A$ ))(! (= (pred_process_term$ ?v0 ?v1 (var$ ?v2 ))(fun_app$b ?v1 ?v2 )):pattern ((pred_process_term$ ?v0 ?v1 (var$ ?v2 ))))):named a10 ))
(assert (! (forall ((?v0 C_bool_fun$ )(?v1 A_bool_fun$ )(?v2 A$ ))(! (= (pred_process_term$a ?v0 ?v1 (var$a ?v2 ))(fun_app$b ?v1 ?v2 )):pattern ((pred_process_term$a ?v0 ?v1 (var$a ?v2 ))))):named a11 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 A$ ))(! (=> (guarded$ ?v0 )(= (isACT$a ?v0 (var$ ?v1 ))(isACT$a ?v0 (fun_app$ ?v0 ?v1 )))):pattern ((isACT$a ?v0 (var$ ?v1 ))))):named a12 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 A$ ))(! (=> (guarded$ ?v0 )(= (isACT$ ?v0 (var$a ?v1 ))(isACT$a ?v0 (fun_app$ ?v0 ?v1 )))):pattern ((isACT$ ?v0 (var$a ?v1 ))))):named a13 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 B_a_process_term$ ))(=> (isACT$a ?v0 ?v1 )(= (prefOf$ (solution$ ?v0 ?v1 ))(pref$ ?v0 ?v1 )))):named a14 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 B_a_process_term$ ))(=> (isACT$a ?v0 ?v1 )(= (contOf$ (solution$ ?v0 ?v1 ))(solution$ ?v0 (cont$ ?v0 ?v1 ))))):named a15 ))
(assert (! (forall ((?v0 A_b_a_process_term_fun$ )(?v1 B_a_process_term$ ))(= (solution$ ?v0 ?v1 )(ite (isACT$a ?v0 ?v1 )(action$ (pref$ ?v0 ?v1 )(solution$ ?v0 (cont$ ?v0 ?v1 )))(choice$ (solution$ ?v0 (cH1$ ?v0 ?v1 ))(solution$ ?v0 (cH2$ ?v0 ?v1 )))))):named a16 ))
(assert (! (forall ((?v0 B_process$ )(?v1 B_process$ )(?v2 B_process$ )(?v3 B_process$ ))(= (= (choice$ ?v0 ?v1 )(choice$ ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a17 ))
(check-sat )
;(get-unsat-core )
