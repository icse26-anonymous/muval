;(set-option :produce-unsat-cores true )
(set-logic ALL_SUPPORTED )
(declare-sort A$ 0 )
(declare-sort B$ 0 )
(declare-sort Nat$ 0 )
(declare-sort A_set$ 0 )
(declare-sort B_set$ 0 )
(declare-sort A_a_fun$ 0 )
(declare-sort A_b_fun$ 0 )
(declare-sort B_a_fun$ 0 )
(declare-sort B_b_fun$ 0 )
(declare-sort A_list_a_list_fun$ 0 )
(declare-sort A_list_b_list_fun$ 0 )
(declare-sort B_list_a_list_fun$ 0 )
(declare-sort B_list_b_list_fun$ 0 )
(declare-sort A_a_fun_a_a_fun_fun$ 0 )
(declare-sort A_a_fun_a_b_fun_fun$ 0 )
(declare-sort A_b_fun_a_a_fun_fun$ 0 )
(declare-sort A_b_fun_a_b_fun_fun$ 0 )
(declare-sort B_a_fun_b_a_fun_fun$ 0 )
(declare-sort B_a_fun_b_b_fun_fun$ 0 )
(declare-sort B_b_fun_b_a_fun_fun$ 0 )
(declare-sort B_b_fun_b_b_fun_fun$ 0 )
(declare-sort A_a_fun_a_list_a_list_fun_fun$ 0 )
(declare-sort A_b_fun_a_list_b_list_fun_fun$ 0 )
(declare-sort B_a_fun_b_list_a_list_fun_fun$ 0 )
(declare-sort B_b_fun_b_list_b_list_fun_fun$ 0 )
(declare-sort A_stream$ 0)
(declare-sort B_stream$ 0)
(declare-fun shd$ (A_stream$)A$)
(declare-fun stl$ (A_stream$)A_stream$)
(declare-fun sCons$ (A$ A_stream$ )A_stream$)
(declare-fun shd$a (B_stream$)B$)
(declare-fun stl$a (B_stream$)B_stream$)
(declare-fun sCons$a (B$ B_stream$ )B_stream$)
(declare-sort B_list$ 0)
(declare-sort A_list$ 0)
(declare-fun nil$ ()B_list$)
(declare-fun hd$ (B_list$)B$)
(declare-fun tl$ (B_list$)B_list$)
(declare-fun cons$ (B$ B_list$ )B_list$)
(declare-fun nil$a ()A_list$)
(declare-fun hd$a (A_list$)A$)
(declare-fun tl$a (A_list$)A_list$)
(declare-fun cons$a (A$ A_list$ )A_list$)
(declare-fun f$ ()B_a_fun$ )
(declare-fun s$ ()B_stream$ )
(declare-fun id$ ()B_b_fun$ )
(declare-fun xs$ ()B_list$ )
(declare-fun id$a ()A_a_fun$ )
(declare-fun map$ ()B_a_fun_b_list_a_list_fun_fun$ )
(declare-fun comp$ (B_b_fun$ )A_b_fun_a_b_fun_fun$ )
(declare-fun map$a ()A_a_fun_a_list_a_list_fun_fun$ )
(declare-fun map$b ()A_b_fun_a_list_b_list_fun_fun$ )
(declare-fun map$c ()B_b_fun_b_list_b_list_fun_fun$ )
(declare-fun smap$ (B_a_fun$ B_stream$ )A_stream$ )
(declare-fun sset$ (A_stream$ )A_set$ )
(declare-fun comp$a (A_b_fun$ )A_a_fun_a_b_fun_fun$ )
(declare-fun comp$b (A_b_fun$ )B_a_fun_b_b_fun_fun$ )
(declare-fun comp$c (B_a_fun$ )A_b_fun_a_a_fun_fun$ )
(declare-fun comp$d (B_b_fun$ )B_b_fun_b_b_fun_fun$ )
(declare-fun comp$e (A_a_fun$ )A_a_fun_a_a_fun_fun$ )
(declare-fun comp$f (A_a_fun$ )B_a_fun_b_a_fun_fun$ )
(declare-fun comp$g (B_a_fun$ )B_b_fun_b_a_fun_fun$ )
(declare-fun shift$ (B_list$ B_stream$ )B_stream$ )
(declare-fun smap$a (A_b_fun$ A_stream$ )B_stream$ )
(declare-fun smap$b (B_b_fun$ B_stream$ )B_stream$ )
(declare-fun smap$c (A_a_fun$ A_stream$ )A_stream$ )
(declare-fun sset$a (B_stream$ )B_set$ )
(declare-fun member$ (A$ A_set$ )Bool )
(declare-fun shift$a (A_list$ A_stream$ )A_stream$ )
(declare-fun fun_app$ (B_list_a_list_fun$ B_list$ )A_list$ )
(declare-fun member$a (B$ B_set$ )Bool )
(declare-fun fun_app$a (B_a_fun_b_list_a_list_fun_fun$ B_a_fun$ )B_list_a_list_fun$ )
(declare-fun fun_app$b (A_b_fun$ A$ )B$ )
(declare-fun fun_app$c (B_b_fun$ B$ )B$ )
(declare-fun fun_app$d (A_a_fun$ A$ )A$ )
(declare-fun fun_app$e (B_a_fun$ B$ )A$ )
(declare-fun fun_app$f (A_b_fun_a_b_fun_fun$ A_b_fun$ )A_b_fun$ )
(declare-fun fun_app$g (A_a_fun_a_b_fun_fun$ A_a_fun$ )A_b_fun$ )
(declare-fun fun_app$h (B_a_fun_b_b_fun_fun$ B_a_fun$ )B_b_fun$ )
(declare-fun fun_app$i (A_b_fun_a_a_fun_fun$ A_b_fun$ )A_a_fun$ )
(declare-fun fun_app$j (B_b_fun_b_b_fun_fun$ B_b_fun$ )B_b_fun$ )
(declare-fun fun_app$k (A_a_fun_a_a_fun_fun$ A_a_fun$ )A_a_fun$ )
(declare-fun fun_app$l (B_a_fun_b_a_fun_fun$ B_a_fun$ )B_a_fun$ )
(declare-fun fun_app$m (B_b_fun_b_a_fun_fun$ B_b_fun$ )B_a_fun$ )
(declare-fun fun_app$n (B_list_b_list_fun$ B_list$ )B_list$ )
(declare-fun fun_app$o (B_b_fun_b_list_b_list_fun_fun$ B_b_fun$ )B_list_b_list_fun$ )
(declare-fun fun_app$p (A_list_b_list_fun$ A_list$ )B_list$ )
(declare-fun fun_app$q (A_b_fun_a_list_b_list_fun_fun$ A_b_fun$ )A_list_b_list_fun$ )
(declare-fun fun_app$r (A_list_a_list_fun$ A_list$ )A_list$ )
(declare-fun fun_app$s (A_a_fun_a_list_a_list_fun_fun$ A_a_fun$ )A_list_a_list_fun$ )
(declare-fun replicate$ (Nat$ B$ )B_list$ )
(declare-fun replicate$a (Nat$ A$ )A_list$ )
(declare-fun map_tailrec$ ()A_a_fun_a_list_a_list_fun_fun$ )
(declare-fun map_tailrec$a ()A_b_fun_a_list_b_list_fun_fun$ )
(declare-fun map_tailrec$b ()B_b_fun_b_list_b_list_fun_fun$ )
(declare-fun map_tailrec$c ()B_a_fun_b_list_a_list_fun_fun$ )
(assert (! (not (= (smap$ f$ (shift$ xs$ s$ ))(shift$a (fun_app$ (fun_app$a map$ f$ )xs$ )(smap$ f$ s$ )))):named a0 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_stream$ ))(= (shd$a (smap$a ?v0 ?v1 ))(fun_app$b ?v0 (shd$ ?v1 )))):named a1 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_stream$ ))(= (shd$a (smap$b ?v0 ?v1 ))(fun_app$c ?v0 (shd$a ?v1 )))):named a2 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_stream$ ))(= (shd$ (smap$c ?v0 ?v1 ))(fun_app$d ?v0 (shd$ ?v1 )))):named a3 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_stream$ ))(= (shd$ (smap$ ?v0 ?v1 ))(fun_app$e ?v0 (shd$a ?v1 )))):named a4 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_stream$ ))(= (stl$a (smap$a ?v0 ?v1 ))(smap$a ?v0 (stl$ ?v1 )))):named a5 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_stream$ ))(= (stl$a (smap$b ?v0 ?v1 ))(smap$b ?v0 (stl$a ?v1 )))):named a6 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_stream$ ))(= (stl$ (smap$c ?v0 ?v1 ))(smap$c ?v0 (stl$ ?v1 )))):named a7 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_stream$ ))(= (stl$ (smap$ ?v0 ?v1 ))(smap$ ?v0 (stl$a ?v1 )))):named a8 ))
(assert (! (forall ((?v0 B_stream$ ))(! (= (shift$ nil$ ?v0 )?v0 ):pattern ((shift$ nil$ ?v0 )))):named a9 ))
(assert (! (forall ((?v0 A_stream$ ))(! (= (shift$a nil$a ?v0 )?v0 ):pattern ((shift$a nil$a ?v0 )))):named a10 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_stream$ )(?v2 A_b_fun$ )(?v3 A_b_fun$ ))(=> (and (forall ((?v4 A$ )(?v5 A$ ))(=> (and (member$ ?v4 (sset$ ?v0 ))(and (member$ ?v5 (sset$ ?v1 ))(= (fun_app$b ?v2 ?v4 )(fun_app$b ?v3 ?v5 ))))(= ?v4 ?v5 )))(= (smap$a ?v2 ?v0 )(smap$a ?v3 ?v1 )))(= ?v0 ?v1 ))):named a11 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_stream$ )(?v2 A_a_fun$ )(?v3 A_a_fun$ ))(=> (and (forall ((?v4 A$ )(?v5 A$ ))(=> (and (member$ ?v4 (sset$ ?v0 ))(and (member$ ?v5 (sset$ ?v1 ))(= (fun_app$d ?v2 ?v4 )(fun_app$d ?v3 ?v5 ))))(= ?v4 ?v5 )))(= (smap$c ?v2 ?v0 )(smap$c ?v3 ?v1 )))(= ?v0 ?v1 ))):named a12 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_stream$ )(?v2 B_b_fun$ )(?v3 B_b_fun$ ))(=> (and (forall ((?v4 B$ )(?v5 B$ ))(=> (and (member$a ?v4 (sset$a ?v0 ))(and (member$a ?v5 (sset$a ?v1 ))(= (fun_app$c ?v2 ?v4 )(fun_app$c ?v3 ?v5 ))))(= ?v4 ?v5 )))(= (smap$b ?v2 ?v0 )(smap$b ?v3 ?v1 )))(= ?v0 ?v1 ))):named a13 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_stream$ )(?v2 B_a_fun$ )(?v3 B_a_fun$ ))(=> (and (forall ((?v4 B$ )(?v5 B$ ))(=> (and (member$a ?v4 (sset$a ?v0 ))(and (member$a ?v5 (sset$a ?v1 ))(= (fun_app$e ?v2 ?v4 )(fun_app$e ?v3 ?v5 ))))(= ?v4 ?v5 )))(= (smap$ ?v2 ?v0 )(smap$ ?v3 ?v1 )))(= ?v0 ?v1 ))):named a14 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_b_fun$ )(?v2 A_b_fun$ ))(=> (forall ((?v3 A$ ))(=> (member$ ?v3 (sset$ ?v0 ))(= (fun_app$b ?v1 ?v3 )(fun_app$b ?v2 ?v3 ))))(= (smap$a ?v1 ?v0 )(smap$a ?v2 ?v0 )))):named a15 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_a_fun$ )(?v2 A_a_fun$ ))(=> (forall ((?v3 A$ ))(=> (member$ ?v3 (sset$ ?v0 ))(= (fun_app$d ?v1 ?v3 )(fun_app$d ?v2 ?v3 ))))(= (smap$c ?v1 ?v0 )(smap$c ?v2 ?v0 )))):named a16 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_b_fun$ )(?v2 B_b_fun$ ))(=> (forall ((?v3 B$ ))(=> (member$a ?v3 (sset$a ?v0 ))(= (fun_app$c ?v1 ?v3 )(fun_app$c ?v2 ?v3 ))))(= (smap$b ?v1 ?v0 )(smap$b ?v2 ?v0 )))):named a17 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_a_fun$ )(?v2 B_a_fun$ ))(=> (forall ((?v3 B$ ))(=> (member$a ?v3 (sset$a ?v0 ))(= (fun_app$e ?v1 ?v3 )(fun_app$e ?v2 ?v3 ))))(= (smap$ ?v1 ?v0 )(smap$ ?v2 ?v0 )))):named a18 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_stream$ )(?v2 A_b_fun$ )(?v3 A_b_fun$ ))(=> (and (= ?v0 ?v1 )(forall ((?v4 A$ ))(=> (member$ ?v4 (sset$ ?v1 ))(= (fun_app$b ?v2 ?v4 )(fun_app$b ?v3 ?v4 )))))(= (smap$a ?v2 ?v0 )(smap$a ?v3 ?v1 )))):named a19 ))
(assert (! (forall ((?v0 A_stream$ )(?v1 A_stream$ )(?v2 A_a_fun$ )(?v3 A_a_fun$ ))(=> (and (= ?v0 ?v1 )(forall ((?v4 A$ ))(=> (member$ ?v4 (sset$ ?v1 ))(= (fun_app$d ?v2 ?v4 )(fun_app$d ?v3 ?v4 )))))(= (smap$c ?v2 ?v0 )(smap$c ?v3 ?v1 )))):named a20 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_stream$ )(?v2 B_b_fun$ )(?v3 B_b_fun$ ))(=> (and (= ?v0 ?v1 )(forall ((?v4 B$ ))(=> (member$a ?v4 (sset$a ?v1 ))(= (fun_app$c ?v2 ?v4 )(fun_app$c ?v3 ?v4 )))))(= (smap$b ?v2 ?v0 )(smap$b ?v3 ?v1 )))):named a21 ))
(assert (! (forall ((?v0 B_stream$ )(?v1 B_stream$ )(?v2 B_a_fun$ )(?v3 B_a_fun$ ))(=> (and (= ?v0 ?v1 )(forall ((?v4 B$ ))(=> (member$a ?v4 (sset$a ?v1 ))(= (fun_app$e ?v2 ?v4 )(fun_app$e ?v3 ?v4 )))))(= (smap$ ?v2 ?v0 )(smap$ ?v3 ?v1 )))):named a22 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B$ )(?v2 B_stream$ ))(! (= (smap$b ?v0 (sCons$a ?v1 ?v2 ))(sCons$a (fun_app$c ?v0 ?v1 )(smap$b ?v0 ?v2 ))):pattern ((smap$b ?v0 (sCons$a ?v1 ?v2 ))))):named a23 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A$ )(?v2 A_stream$ ))(! (= (smap$a ?v0 (sCons$ ?v1 ?v2 ))(sCons$a (fun_app$b ?v0 ?v1 )(smap$a ?v0 ?v2 ))):pattern ((smap$a ?v0 (sCons$ ?v1 ?v2 ))))):named a24 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A$ )(?v2 A_stream$ ))(! (= (smap$c ?v0 (sCons$ ?v1 ?v2 ))(sCons$ (fun_app$d ?v0 ?v1 )(smap$c ?v0 ?v2 ))):pattern ((smap$c ?v0 (sCons$ ?v1 ?v2 ))))):named a25 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B$ )(?v2 B_stream$ ))(! (= (smap$ ?v0 (sCons$a ?v1 ?v2 ))(sCons$ (fun_app$e ?v0 ?v1 )(smap$ ?v0 ?v2 ))):pattern ((smap$ ?v0 (sCons$a ?v1 ?v2 ))))):named a26 ))
(assert (! (= map$a map_tailrec$ ):named a27 ))
(assert (! (= map$b map_tailrec$a ):named a28 ))
(assert (! (= map$c map_tailrec$b ):named a29 ))
(assert (! (= map$ map_tailrec$c ):named a30 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 A_b_fun$ )(?v2 A_stream$ ))(= (smap$b ?v0 (smap$a ?v1 ?v2 ))(smap$a (fun_app$f (comp$ ?v0 )?v1 )?v2 ))):named a31 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_a_fun$ )(?v2 A_stream$ ))(= (smap$a ?v0 (smap$c ?v1 ?v2 ))(smap$a (fun_app$g (comp$a ?v0 )?v1 )?v2 ))):named a32 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 B_a_fun$ )(?v2 B_stream$ ))(= (smap$a ?v0 (smap$ ?v1 ?v2 ))(smap$b (fun_app$h (comp$b ?v0 )?v1 )?v2 ))):named a33 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 A_b_fun$ )(?v2 A_stream$ ))(= (smap$ ?v0 (smap$a ?v1 ?v2 ))(smap$c (fun_app$i (comp$c ?v0 )?v1 )?v2 ))):named a34 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_b_fun$ )(?v2 B_stream$ ))(= (smap$b ?v0 (smap$b ?v1 ?v2 ))(smap$b (fun_app$j (comp$d ?v0 )?v1 )?v2 ))):named a35 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_a_fun$ )(?v2 A_stream$ ))(= (smap$c ?v0 (smap$c ?v1 ?v2 ))(smap$c (fun_app$k (comp$e ?v0 )?v1 )?v2 ))):named a36 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 B_a_fun$ )(?v2 B_stream$ ))(= (smap$c ?v0 (smap$ ?v1 ?v2 ))(smap$ (fun_app$l (comp$f ?v0 )?v1 )?v2 ))):named a37 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_b_fun$ )(?v2 B_stream$ ))(= (smap$ ?v0 (smap$b ?v1 ?v2 ))(smap$ (fun_app$m (comp$g ?v0 )?v1 )?v2 ))):named a38 ))
(assert (! (forall ((?v0 B_stream$ ))(= (smap$b id$ ?v0 )?v0 )):named a39 ))
(assert (! (forall ((?v0 A_stream$ ))(= (smap$c id$a ?v0 )?v0 )):named a40 ))
(assert (! (forall ((?v0 B$ )(?v1 B_list$ )(?v2 B_stream$ ))(! (= (shift$ (cons$ ?v0 ?v1 )?v2 )(sCons$a ?v0 (shift$ ?v1 ?v2 ))):pattern ((shift$ (cons$ ?v0 ?v1 )?v2 )))):named a41 ))
(assert (! (forall ((?v0 A$ )(?v1 A_list$ )(?v2 A_stream$ ))(! (= (shift$a (cons$a ?v0 ?v1 )?v2 )(sCons$ ?v0 (shift$a ?v1 ?v2 ))):pattern ((shift$a (cons$a ?v0 ?v1 )?v2 )))):named a42 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 Nat$ )(?v2 B$ ))(= (fun_app$n (fun_app$o map$c ?v0 )(replicate$ ?v1 ?v2 ))(replicate$ ?v1 (fun_app$c ?v0 ?v2 )))):named a43 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 Nat$ )(?v2 A$ ))(= (fun_app$p (fun_app$q map$b ?v0 )(replicate$a ?v1 ?v2 ))(replicate$ ?v1 (fun_app$b ?v0 ?v2 )))):named a44 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 Nat$ )(?v2 A$ ))(= (fun_app$r (fun_app$s map$a ?v0 )(replicate$a ?v1 ?v2 ))(replicate$a ?v1 (fun_app$d ?v0 ?v2 )))):named a45 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 Nat$ )(?v2 B$ ))(= (fun_app$ (fun_app$a map$ ?v0 )(replicate$ ?v1 ?v2 ))(replicate$a ?v1 (fun_app$e ?v0 ?v2 )))):named a46 ))
(assert (! (forall ((?v0 A$ )(?v1 A_list$ )(?v2 A$ )(?v3 A_list$ ))(= (= (cons$a ?v0 ?v1 )(cons$a ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a47 ))
(assert (! (forall ((?v0 B$ )(?v1 B_list$ )(?v2 B$ )(?v3 B_list$ ))(= (= (cons$ ?v0 ?v1 )(cons$ ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a48 ))
(assert (! (forall ((?v0 B$ )(?v1 B_stream$ )(?v2 B$ )(?v3 B_stream$ ))(= (= (sCons$a ?v0 ?v1 )(sCons$a ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a49 ))
(assert (! (forall ((?v0 A$ )(?v1 A_stream$ )(?v2 A$ )(?v3 A_stream$ ))(= (= (sCons$ ?v0 ?v1 )(sCons$ ?v2 ?v3 ))(and (= ?v0 ?v2 )(= ?v1 ?v3 )))):named a50 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_list$ ))(= (= nil$a (fun_app$r (fun_app$s map$a ?v0 )?v1 ))(= ?v1 nil$a ))):named a51 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_list$ ))(= (= nil$ (fun_app$p (fun_app$q map$b ?v0 )?v1 ))(= ?v1 nil$a ))):named a52 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_list$ ))(= (= nil$ (fun_app$n (fun_app$o map$c ?v0 )?v1 ))(= ?v1 nil$ ))):named a53 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_list$ ))(= (= nil$a (fun_app$ (fun_app$a map$ ?v0 )?v1 ))(= ?v1 nil$ ))):named a54 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_list$ ))(= (= (fun_app$r (fun_app$s map$a ?v0 )?v1 )nil$a )(= ?v1 nil$a ))):named a55 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_list$ ))(= (= (fun_app$p (fun_app$q map$b ?v0 )?v1 )nil$ )(= ?v1 nil$a ))):named a56 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_list$ ))(= (= (fun_app$n (fun_app$o map$c ?v0 )?v1 )nil$ )(= ?v1 nil$ ))):named a57 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_list$ ))(= (= (fun_app$ (fun_app$a map$ ?v0 )?v1 )nil$a )(= ?v1 nil$ ))):named a58 ))
(assert (! (forall ((?v0 A_a_fun$ )(?v1 A_list$ ))(= (= (fun_app$r (fun_app$s map$a ?v0 )?v1 )nil$a )(= ?v1 nil$a ))):named a59 ))
(assert (! (forall ((?v0 A_b_fun$ )(?v1 A_list$ ))(= (= (fun_app$p (fun_app$q map$b ?v0 )?v1 )nil$ )(= ?v1 nil$a ))):named a60 ))
(assert (! (forall ((?v0 B_b_fun$ )(?v1 B_list$ ))(= (= (fun_app$n (fun_app$o map$c ?v0 )?v1 )nil$ )(= ?v1 nil$ ))):named a61 ))
(assert (! (forall ((?v0 B_a_fun$ )(?v1 B_list$ ))(= (= (fun_app$ (fun_app$a map$ ?v0 )?v1 )nil$a )(= ?v1 nil$ ))):named a62 ))
(check-sat )
;(get-unsat-core )
