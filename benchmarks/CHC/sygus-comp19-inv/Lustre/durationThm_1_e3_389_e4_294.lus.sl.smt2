(set-logic HORN)

(declare-fun str_invariant
             (Int
              Int
              Bool
              Bool
              Bool
              Bool
              Bool
              Int
              Int
              Int
              Int
              Bool
              Bool
              Bool
              Bool
              Bool)
             Bool)
(assert (forall ((A Bool)
         (B Bool)
         (C Bool)
         (D Bool)
         (E Bool)
         (F Int)
         (G Int)
         (H Int)
         (I Int)
         (J Bool)
         (K Bool)
         (L Bool)
         (M Bool)
         (N Bool)
         (O Int)
         (P Int))
  (=> (and (str_invariant P O N M L K J I H G F E D C B A) (not (= K true)))
         false)
    ))
(assert (forall ((A Bool)
         (B Bool)
         (C Bool)
         (D Bool)
         (E Bool)
         (F Int)
         (G Int)
         (H Int)
         (I Int)
         (J Bool)
         (K Bool)
         (L Bool)
         (M Bool)
         (N Bool)
         (O Int)
         (P Int))
  (let ((a!1 (and (>= (+ (- 1) I) 0)
                     (>= (+ (- 1) H) 0)
                     (or (< (- G I) 0) (= M true))
                     (or (< (- F H) 0) (= L true))))
           (a!2 (or (< (+ (- 1) I) 0)
                    (< (+ (- 1) H) 0)
                    (and (>= (- G I) 0) (not (= M true)))
                    (and (>= (- F H) 0) (not (= L true)))
                    (= E true))))
     (let ((a!3 (and (or (= E true) (not (= D true)))
                     (or (not (= E true)) (= D true))
                     (= K true)
                     (= G 0)
                     (= C true)
                     (= (- I P) 0)
                     (= F 0)
                     (= B true)
                     (or a!1 (not (= E true)))
                     (= (- H O) 0)
                     (= A true)
                     a!2
                     (= J true))))
       (=> a!3 (str_invariant P O N M L K J I H G F E D C B A))))
    ))
(assert (forall ((A Int)
         (B Int)
         (C Bool)
         (D Bool)
         (E Bool)
         (F Bool)
         (G Bool)
         (H Bool)
         (I Bool)
         (J Bool)
         (K Bool)
         (L Bool)
         (M Int)
         (N Int)
         (O Int)
         (P Int)
         (Q Bool)
         (R Bool)
         (S Bool)
         (T Bool)
         (U Int)
         (V Bool)
         (W Int)
         (X Int)
         (Y Bool)
         (Z Bool)
         (A1 Bool)
         (B1 Bool)
         (C1 Bool)
         (D1 Int)
         (E1 Int)
         (F1 Int))
  (let ((a!1 (or (not (= B1 true))
                    (< (- (- E1 B) A) 0)
                    (= E true)
                    (not (= D true))))
           (a!2 (and (= B1 true) (>= (- (- E1 B) A) 0) (not (= E true))))
           (a!3 (= (- E1 (ite (= V true) N 0)) 0))
           (a!4 (= (- D1 (ite (= T true) M 0)) 0))
           (a!5 (and (>= (+ (- 1) B) 0)
                     (>= (+ (- 1) A) 0)
                     (or (< (- E1 B) 0) (= F true))
                     (or (< (- D1 A) 0) (= E true))))
           (a!6 (or (< (+ (- 1) B) 0)
                    (< (+ (- 1) A) 0)
                    (and (>= (- E1 B) 0) (not (= F true)))
                    (and (>= (- D1 A) 0) (not (= E true)))
                    (= C1 true))))
     (let ((a!7 (and (str_invariant X W V T S R Q P O N M L K I H G)
                     (or (and (= C1 true) (= K true)) (not (= B1 true)))
                     a!1
                     (or (not (= C1 true)) (not (= K true)) (= B1 true))
                     (or a!2 (= D true))
                     a!3
                     (not (= A1 true))
                     (= (- A O) 0)
                     a!4
                     (not (= Z true))
                     (or a!5 (not (= C1 true)))
                     (= (- B P) 0)
                     (not (= Y true))
                     a!6
                     (not (= C true)))))
       (=> a!7 (str_invariant F1 U J F E D C B A E1 D1 C1 B1 A1 Z Y))))
    ))


(check-sat)
(exit)
